# 1. 정렬/탐색

#### 이진트리의 특징

>이미 오름차순, 내림차순등으로 정렬이 되어 있다.
>
>예시를 들면 1~100까지의 숫자를 상대방이 생각하고 이를 up, down을 이용해 답을 유추하는 것과 비슷하다.

```python
##이진트리 검색법
def solution(L, a, b, k):
    mid = (a + b)//2
    print(a,b,mid)

    if b < a or a < 0 : return print(-1)
    if L[mid] < k : return solution(L,mid-1,b,k)
    if L[mid] > k : return solution(L,a,mid-1, k)
    if L[mid] == k : return print(mid)

import sys
sys.setrecursionlimit(10**7)

solution( [2, 5, 7, 9, 11], 0, len([2, 5, 7, 9, 11])-1, 4)
```

- programmers 답지

```python
def solution(L, x):
    answer = 0
    a = 0
    b = len(L)-1
    while True :
        mid = (a+b)//2
        print(a,b,mid)
        if b < a or a < 0: 
            return -1
        if L[mid] < x:
            a = mid + 1
        if L[mid] > x :
            b = mid - 1
        if L[mid] == x:
            return mid
        
    return answer

solution([2, 5, 7, 9, 11], 4)
```



# 2. 재귀함수

#### 재귀함수 특징

>
>
>o(n)
>
>함수를 다시 부른다는 의미로써 생각보다 효율이 좋다.
>
>예시로는 합계를 들수 있다.
>
>```python
>sum(n) = sum(n-1) + n
>sum(n) = sum(n-2) + n-1 + n
>...
>sum(n) = sum(1) + 2 + 3 + 4 + ... + n-1 + n
>```
>
>재귀적 용법의 경우  Trivial  case(사소한 경우) 를 고려하지 않기 쉽다.
>
>

#### 피보나치

```python
# 피보나치(프로그래머스)
def solution(x):
    answer = 0
    answer2 = 1
    emp = 0
    n = 2
    if x == 0 : return 0
    if x == 1 : return 1
    ## 주의점! for i in range(2,x)를 하게되는 경우  for문을 작동하지 않는다.
    for i in range(1,x): 
        emp = answer2
        
        answer2 = answer + answer2  
          
        answer = emp
        print(answer, answer2)    
    return answer2

x = int(input())
solution(x)

############################ 다른 방법이지만 효율이 정말 험악하다...
def fibo(n):
    if n<=1:
        return n
    return fibo(n-1) + fibo(n-2)

```



#### 조합의 수 계산

```python
#문제  n개의 서로 다른 원소에서 m개를 택하는 경우의 수
def sol(n, m):
    return f(n)/(f(m)*f(n-m))

```

- 하노이의 탑을 한번 만들어 보자!