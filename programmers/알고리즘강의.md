# 1. 정렬/탐색

#### 이진트리의 특징

>이미 오름차순, 내림차순등으로 정렬이 되어 있다.
>
>예시를 들면 1~100까지의 숫자를 상대방이 생각하고 이를 up, down을 이용해 답을 유추하는 것과 비슷하다.

```python
##이진트리 검색법
def solution(L, a, b, k):
    mid = (a + b)//2
    print(a,b,mid)

    if b < a or a < 0 : return print(-1)
    if L[mid] < k : return solution(L,mid-1,b,k)
    if L[mid] > k : return solution(L,a,mid-1, k)
    if L[mid] == k : return print(mid)

import sys
sys.setrecursionlimit(10**7)

solution( [2, 5, 7, 9, 11], 0, len([2, 5, 7, 9, 11])-1, 4)
```

- programmers 답지

```python
def solution(L, x):
    answer = 0
    a = 0
    b = len(L)-1
    while True :
        mid = (a+b)//2
        print(a,b,mid)
        if b < a or a < 0: 
            return -1
        if L[mid] < x:
            a = mid + 1
        if L[mid] > x :
            b = mid - 1
        if L[mid] == x:
            return mid
        
    return answer

solution([2, 5, 7, 9, 11], 4)
```



# 2. 재귀함수

#### 재귀함수 특징

>
>
>o(n)
>
>함수를 다시 부른다는 의미로써 생각보다 효율이 좋다.
>
>예시로는 합계를 들수 있다.
>
>```python
>sum(n) = sum(n-1) + n
>sum(n) = sum(n-2) + n-1 + n
>...
>sum(n) = sum(1) + 2 + 3 + 4 + ... + n-1 + n
>```
>
>재귀적 용법의 경우  Trivial  case(사소한 경우) 를 고려하지 않기 쉽다.
>
>

#### 피보나치

```python
# 피보나치(프로그래머스)
def solution(x):
    answer = 0
    answer2 = 1
    emp = 0
    n = 2
    if x == 0 : return 0
    if x == 1 : return 1
    ## 주의점! for i in range(2,x)를 하게되는 경우  for문을 작동하지 않는다.
    for i in range(1,x): 
        emp = answer2
        
        answer2 = answer + answer2  
          
        answer = emp
        print(answer, answer2)    
    return answer2

x = int(input())
solution(x)

############################ 다른 방법이지만 효율이 정말 험악하다...
def fibo(n):
    if n<=1:
        return n
    return fibo(n-1) + fibo(n-2)

```



#### 조합의 수 계산

```python
#문제  n개의 서로 다른 원소에서 m개를 택하는 경우의 수
def sol(n, m):
    return f(n)/(f(m)*f(n-m))

```

- 하노이의 탑을 한번 만들어 보자!



# 3. 알고리즘 복잡도

> ### 시간 복잡도
>
> - 문제의 크기와 이를 해결하는 데 걸리는 시간 사이의 관계
>
> ### 공간 복잡도
>
> - 문제의 크기와 이를 해결하는데 필요한 메모리 공간 사이의 관계
>
> ### 평균 시간 복잡도(average time complexity)
>
> - 임의의 입력 패턴을 가정했을 때 소요되는 시간의 평균
>
> ### 최악 시간 복잡도(worst-case time complexity)
>
> - 가장 긴 시간을 소요하게 만드는 입력에 따라 소요되는 시간

## 표기법(Big-O notation)

> 점근 표기법이 하나 
>
> - 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현

- 선형 시간 알고리즘 - O(n)

  > Average case : O(n)
  >
  > Worst case : O(n)

- 로그 시간 알고리즘 - O(logn)

  > 크기 순으로 정렬된 수에서 이진 탐색 알고리즘을 적용시 

- 이차 시간 알고리즘 - O(n²)

  > 삽입정렬을 예로 들수 있다. (insertion sort)
  >
  > Best case :O(n)
  >
  > Worst case : O(n²)

# 4. 연결 리스트

```python
class Node:
    def __init__(self, item):
        self.data = item
        self.next = None

class LinkedList:
    def __init__(self):
        self.nodeCount = 0
        self.head = None
        self.tail = None
        print("-init-linkedlist", self.nodeCount, self.head, self.tail)
    def getAt(self, pos):
        if pos < 1 or pos > self.nodeCount:
            return None
        i = 1
        curr = self.head
        while i < pos:
            curr = curr.next
            i += 1
        return curr

    def traverse(self):
        
        reanwser = [50,60,70]
        for i in reanwser:
            reanwser.remove(LinkedList.getAt(i))
        return reanwser

print(LinkedList.traverse)


```

```python
class Node:
    def __init__ (self, key = None):
        self.data = key
        self.next = None
    def __str__ (self):
        return str(self.key)
    #Node(v.key) => Node(v) 표현 가능하게 한다.

a = Node(3)
b = Node(9)
c = Node(-1)
a.next = b
b.next = c

class SinglyLinkedList:
    def __init__ (self):
        self.head = None
        self.size = 0
    def __len__ (self):
        return self.size

```

```python
class Node:

    def __init__(self, item):
        self.data = item
        self.next = None


class LinkedList:

    def __init__(self):
        self.nodeCount = 0
        self.head = None
        self.tail = None


    def getAt(self, pos):
        if pos < 1 or pos > self.nodeCount:
            return None

        i = 1
        curr = self.head
        while i < pos:
            curr = curr.next
            i += 1

        return curr


    def insertAt(self, pos, newNode):
        if pos < 1 or pos > self.nodeCount + 1:
            return False

        if pos == 1:
            newNode.next = self.head
            self.head = newNode

        else:
            if pos == self.nodeCount + 1:
                prev = self.tail
            else:
                prev = self.getAt(pos - 1)
            newNode.next = prev.next
            prev.next = newNode

        if pos == self.nodeCount + 1:
            self.tail = newNode

        self.nodeCount += 1
        return True


    def popAt(self, pos):
        if pos < 1 or pos > self.nodeCount + 1:
            return False
        else :
            if pos == 1:
                self.head = self.getAt(pos+1)
            else :
                self.curr = self.getAt(pos+1)
        
        return self.getAt(pos)
    def traverse(self):
        result = []
        curr = self.head
        while curr is not None:
            result.append(curr.data)
            curr = curr.next
        return result


def solution(x):
    return 0
```

```

```



